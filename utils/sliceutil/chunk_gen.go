// Code generated by "github.com/beanscc/rango/cmd/genericgenerator -method chunk -etype int8,int16,int,int32,int64,uint8,uint16,uint,uint32,uint64,float32,float64,string"; DO NOT EDIT.

package sliceutil

// Chunk 将切片按 size 大小分块
func Chunk(slice interface{}, size int) interface{} {
	switch slice.(type) {
	case []int8:
		return ChunkInt8s(slice.([]int8), size)
	case []int16:
		return ChunkInt16s(slice.([]int16), size)
	case []int:
		return ChunkInts(slice.([]int), size)
	case []int32:
		return ChunkInt32s(slice.([]int32), size)
	case []int64:
		return ChunkInt64s(slice.([]int64), size)
	case []uint8:
		return ChunkUint8s(slice.([]uint8), size)
	case []uint16:
		return ChunkUint16s(slice.([]uint16), size)
	case []uint:
		return ChunkUints(slice.([]uint), size)
	case []uint32:
		return ChunkUint32s(slice.([]uint32), size)
	case []uint64:
		return ChunkUint64s(slice.([]uint64), size)
	case []float32:
		return ChunkFloat32s(slice.([]float32), size)
	case []float64:
		return ChunkFloat64s(slice.([]float64), size)
	case []string:
		return ChunkStrings(slice.([]string), size)
	default:
		return chunkReflect(slice, size)
	}
}

// ChunkInt8s 将 []int8 切片按 size 大小分块，返回一个新的切片[][]int8
func ChunkInt8s(slice []int8, size int) [][]int8 {
	l := len(slice)
	chunks := make([][]int8, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkInt16s 将 []int16 切片按 size 大小分块，返回一个新的切片[][]int16
func ChunkInt16s(slice []int16, size int) [][]int16 {
	l := len(slice)
	chunks := make([][]int16, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkInts 将 []int 切片按 size 大小分块，返回一个新的切片[][]int
func ChunkInts(slice []int, size int) [][]int {
	l := len(slice)
	chunks := make([][]int, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkInt32s 将 []int32 切片按 size 大小分块，返回一个新的切片[][]int32
func ChunkInt32s(slice []int32, size int) [][]int32 {
	l := len(slice)
	chunks := make([][]int32, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkInt64s 将 []int64 切片按 size 大小分块，返回一个新的切片[][]int64
func ChunkInt64s(slice []int64, size int) [][]int64 {
	l := len(slice)
	chunks := make([][]int64, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkUint8s 将 []uint8 切片按 size 大小分块，返回一个新的切片[][]uint8
func ChunkUint8s(slice []uint8, size int) [][]uint8 {
	l := len(slice)
	chunks := make([][]uint8, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkUint16s 将 []uint16 切片按 size 大小分块，返回一个新的切片[][]uint16
func ChunkUint16s(slice []uint16, size int) [][]uint16 {
	l := len(slice)
	chunks := make([][]uint16, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkUints 将 []uint 切片按 size 大小分块，返回一个新的切片[][]uint
func ChunkUints(slice []uint, size int) [][]uint {
	l := len(slice)
	chunks := make([][]uint, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkUint32s 将 []uint32 切片按 size 大小分块，返回一个新的切片[][]uint32
func ChunkUint32s(slice []uint32, size int) [][]uint32 {
	l := len(slice)
	chunks := make([][]uint32, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkUint64s 将 []uint64 切片按 size 大小分块，返回一个新的切片[][]uint64
func ChunkUint64s(slice []uint64, size int) [][]uint64 {
	l := len(slice)
	chunks := make([][]uint64, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkFloat32s 将 []float32 切片按 size 大小分块，返回一个新的切片[][]float32
func ChunkFloat32s(slice []float32, size int) [][]float32 {
	l := len(slice)
	chunks := make([][]float32, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkFloat64s 将 []float64 切片按 size 大小分块，返回一个新的切片[][]float64
func ChunkFloat64s(slice []float64, size int) [][]float64 {
	l := len(slice)
	chunks := make([][]float64, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}

// ChunkStrings 将 []string 切片按 size 大小分块，返回一个新的切片[][]string
func ChunkStrings(slice []string, size int) [][]string {
	l := len(slice)
	chunks := make([][]string, 0, chunkCap(l, size))
	for i := 0; i < l; i += size {
		end := i + size
		if end >= l {
			end = l
		}
		chunks = append(chunks, slice[i:end])
	}

	return chunks
}
