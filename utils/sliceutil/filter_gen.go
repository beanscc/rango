// Code generated by "github.com/beanscc/rango/cmd/genericgenerator -method filter -etype int8,int16,int,int32,int64,uint8,uint16,uint,uint32,uint64,float32,float64,string"; DO NOT EDIT.

package sliceutil

// Filter filter() == true 时，保留该项，否则丢弃改项，返回一个新的该类型的切片
func Filter(slice interface{}, filter func(i int) bool) interface{} {
	switch slice.(type) {
	case []int8:
		return FilterInt8s(slice.([]int8), filter)
	case []int16:
		return FilterInt16s(slice.([]int16), filter)
	case []int:
		return FilterInts(slice.([]int), filter)
	case []int32:
		return FilterInt32s(slice.([]int32), filter)
	case []int64:
		return FilterInt64s(slice.([]int64), filter)
	case []uint8:
		return FilterUint8s(slice.([]uint8), filter)
	case []uint16:
		return FilterUint16s(slice.([]uint16), filter)
	case []uint:
		return FilterUints(slice.([]uint), filter)
	case []uint32:
		return FilterUint32s(slice.([]uint32), filter)
	case []uint64:
		return FilterUint64s(slice.([]uint64), filter)
	case []float32:
		return FilterFloat32s(slice.([]float32), filter)
	case []float64:
		return FilterFloat64s(slice.([]float64), filter)
	case []string:
		return FilterStrings(slice.([]string), filter)
	default:
		return filterReflect(slice, filter)
	}
}

// FilterInt8s 过滤 []int8 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterInt8s(slice []int8, filter func(i int) bool) []int8 {
	l := len(slice)
	resp := make([]int8, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterInt16s 过滤 []int16 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterInt16s(slice []int16, filter func(i int) bool) []int16 {
	l := len(slice)
	resp := make([]int16, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterInts 过滤 []int 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterInts(slice []int, filter func(i int) bool) []int {
	l := len(slice)
	resp := make([]int, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterInt32s 过滤 []int32 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterInt32s(slice []int32, filter func(i int) bool) []int32 {
	l := len(slice)
	resp := make([]int32, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterInt64s 过滤 []int64 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterInt64s(slice []int64, filter func(i int) bool) []int64 {
	l := len(slice)
	resp := make([]int64, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterUint8s 过滤 []uint8 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterUint8s(slice []uint8, filter func(i int) bool) []uint8 {
	l := len(slice)
	resp := make([]uint8, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterUint16s 过滤 []uint16 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterUint16s(slice []uint16, filter func(i int) bool) []uint16 {
	l := len(slice)
	resp := make([]uint16, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterUints 过滤 []uint 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterUints(slice []uint, filter func(i int) bool) []uint {
	l := len(slice)
	resp := make([]uint, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterUint32s 过滤 []uint32 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterUint32s(slice []uint32, filter func(i int) bool) []uint32 {
	l := len(slice)
	resp := make([]uint32, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterUint64s 过滤 []uint64 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterUint64s(slice []uint64, filter func(i int) bool) []uint64 {
	l := len(slice)
	resp := make([]uint64, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterFloat32s 过滤 []float32 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterFloat32s(slice []float32, filter func(i int) bool) []float32 {
	l := len(slice)
	resp := make([]float32, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterFloat64s 过滤 []float64 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterFloat64s(slice []float64, filter func(i int) bool) []float64 {
	l := len(slice)
	resp := make([]float64, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}

// FilterStrings 过滤 []string 切片，只保留 filter(i) == true 时的索引项，并返回一个新的该类型切片
func FilterStrings(slice []string, filter func(i int) bool) []string {
	l := len(slice)
	resp := make([]string, 0, l)
	for i := 0; i < l; i++ {
		if filter(i) {
			resp = append(resp, slice[i])
		}
	}

	return resp
}
